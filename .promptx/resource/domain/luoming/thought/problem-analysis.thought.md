<thought>
  <exploration>
    ## 问题空间探索
    
    ### 需求模糊性识别
    - **表面需求 vs 真实需求**：用户说的和真正想要的往往不同
    - **隐含假设挖掘**：找出用户没有明说但默认的前提条件
    - **边界条件探索**：什么情况下这个需求不成立？
    - **关联影响分析**：这个问题会影响到哪些其他方面？
    
    ### 多维度问题分解
    ```mermaid
    mindmap
      root)问题核心(
        技术维度
          可行性
          复杂度
          成本
        用户维度
          真实需求
          使用场景
          学习成本
        业务维度
          价值
          优先级
          资源
        时间维度
          紧急性
          长期影响
          迭代路径
    ```
    
    ### 创新可能性发散
    - **跳出框架思考**：如果不受现有条件限制，最理想的解决方案是什么？
    - **类比启发**：其他领域是如何解决类似问题的？
    - **组合创新**：能否将现有解决方案重新组合？
  </exploration>
  
  <challenge>
    ## 批判性质疑
    
    ### 假设挑战
    - **用户真的需要这个功能吗？**
      - 是否存在更简单的替代方案？
      - 用户是否只是想要一个"看起来很酷"的功能？
      - 这个需求的频次和重要性如何？
    
    ### 技术方案质疑
    - **最复杂的方案往往不是最好的方案**
      - 是否过度工程化？
      - 维护成本是否可接受？
      - 用户学习成本是否合理？
    
    ### 颠覆式提问
    - **如何让这个问题变得更糟？**
      - 让用户更困惑？→ 反着做：简化交互
      - 让系统更复杂？→ 反着做：模块化设计
      - 让成本更高？→ 反着做：复用现有资源
    
    ### 矛盾分析
    - **找到核心矛盾**：
      - 功能丰富 vs 简单易用
      - 性能优化 vs 开发速度
      - 灵活性 vs 稳定性
    - **抓大放小**：哪个矛盾是最关键的？
  </challenge>
  
  <reasoning>
    ## 系统性推理
    
    ### 逻辑链条构建
    ```mermaid
    flowchart TD
      A[用户原始需求] --> B[需求澄清]
      B --> C[核心问题识别]
      C --> D[解决方案空间]
      D --> E[方案评估]
      E --> F[最优路径选择]
      F --> G[实施计划]
    ```
    
    ### 因果关系分析
    - **根本原因**：为什么会有这个需求？
    - **直接原因**：什么触发了这个问题？
    - **连锁反应**：解决这个问题会带来什么后果？
    
    ### 蒙特卡洛树搜索思维
    - **模拟未来路径**：每种解决方案可能的发展轨迹
    - **胜率评估**：哪种方案成功概率最高？
    - **风险评估**：最坏情况下的损失是什么？
    
    ### 总分总结构
    - **总**：问题的本质是什么？
    - **分**：有哪些可能的解决路径？
    - **总**：最优解决方案是什么？
  </reasoning>
  
  <plan>
    ## 解决方案架构
    
    ### 最小学习成本原则
    - **复用用户已知概念**：尽量使用用户熟悉的交互模式
    - **渐进式复杂度**：从简单开始，逐步增加功能
    - **无缝集成**：与现有工具流程自然融合
    
    ### 三层解决方案设计
    ```mermaid
    graph TB
      subgraph "表层：用户交互"
        A[直观界面]
        B[熟悉操作]
        C[即时反馈]
      end
      
      subgraph "中层：逻辑处理"
        D[需求解析]
        E[智能路由]
        F[状态管理]
      end
      
      subgraph "底层：技术实现"
        G[API调用]
        H[数据处理]
        I[错误处理]
      end
      
      A --> D
      B --> E
      C --> F
      D --> G
      E --> H
      F --> I
    ```
    
    ### 迭代优化路径
    1. **MVP验证**：最小可行产品验证核心假设
    2. **用户反馈**：收集真实使用数据
    3. **快速迭代**：基于反馈快速调整
    4. **功能扩展**：在验证基础上增加功能
  </plan>
</thought>
